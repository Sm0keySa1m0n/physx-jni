/****************************************
 * [package=physics]
 ****************************************/

[Prefix="physx::", NoDelete]
interface PxActor {
    PxActorTypeEnum getType();
    PxScene getScene();
    void setName(DOMString name);
    [Const] DOMString getName();
    [Value] PxBounds3 getWorldBounds(optional float inflation);
    void setActorFlag(PxActorFlagEnum flag, boolean value);
    void setActorFlags([Ref] PxActorFlags flags);
    [Value] PxActorFlags getActorFlags();
    void setDominanceGroup(octet dominanceGroup);
    octet getDominanceGroup();
    void setOwnerClient(octet inClient);
    octet getOwnerClient();

    attribute VoidPtr userData;
};
PxActor implements PxBase;

enum PxActorFlagEnum {
    "PxActorFlagEnum::eVISUALIZATION",
    "PxActorFlagEnum::eDISABLE_GRAVITY",
    "PxActorFlagEnum::eSEND_SLEEP_NOTIFIES",
    "PxActorFlagEnum::eDISABLE_SIMULATION"
};

[Prefix="physx::"]
interface PxActorFlags {
    void PxActorFlags(octet flags);
    boolean isSet(PxActorFlagEnum flag);
    void raise(PxActorFlagEnum flag);
    void clear(PxActorFlagEnum flag);
};

[Prefix="physx::"]
interface PxActorShape {
    attribute PxRigidActor actor;
    attribute PxShape shape;
};

[Prefix="physx::"]
interface PxActorTypeFlags {
    void PxActorTypeFlags(unsigned short flags);
    boolean isSet(PxActorTypeFlagEnum flag);
    void raise(PxActorTypeFlagEnum flag);
    void clear(PxActorTypeFlagEnum flag);
};

enum PxActorTypeEnum {
    "PxActorTypeEnum::eRIGID_STATIC",
    "PxActorTypeEnum::eRIGID_DYNAMIC",
    "PxActorTypeEnum::eARTICULATION_LINK",
    "PxActorTypeEnum::eACTOR_COUNT",
    "PxActorTypeEnum::eACTOR_FORCE_DWORD",
};

enum PxActorTypeFlagEnum {
    "PxActorTypeFlagEnum::eRIGID_STATIC",
    "PxActorTypeFlagEnum::eRIGID_DYNAMIC"
};

enum PxCombineModeEnum {
    "PxCombineModeEnum::eAVERAGE",
    "PxCombineModeEnum::eMIN",
    "PxCombineModeEnum::eMULTIPLY",
    "PxCombineModeEnum::eMAX"
};

[Prefix="physx::"]
interface PxFilterData {
    void PxFilterData();
    void PxFilterData(unsigned long w0, unsigned long w1, unsigned long w2, unsigned long w3);
    attribute unsigned long word0;
    attribute unsigned long word1;
    attribute unsigned long word2;
    attribute unsigned long word3;
};

[Prefix="physx::", NoDelete]
interface PxMaterial {
    unsigned long getReferenceCount();
    void acquireReference();
    void setDynamicFriction(float coef);
    float getDynamicFriction();
    void setStaticFriction(float coef);
    float getStaticFriction();
    void setRestitution(float coef);
    float getRestitution();
    void setFlag(PxMaterialFlagEnum flag, boolean b);
    void setFlags([Ref] PxMaterialFlags flags);
    [Value] PxMaterialFlags getFlags();
    void setFrictionCombineMode(PxCombineModeEnum combMode);
    PxCombineModeEnum getFrictionCombineMode();
    void setRestitutionCombineMode(PxCombineModeEnum combMode);
    PxCombineModeEnum getRestitutionCombineMode();

    attribute VoidPtr userData;
};
PxMaterial implements PxBase;

enum PxMaterialFlagEnum {
    "PxMaterialFlagEnum::eDISABLE_FRICTION",
    "PxMaterialFlagEnum::eDISABLE_STRONG_FRICTION",
    "PxMaterialFlagEnum::eIMPROVED_PATCH_FRICTION",
};

[Prefix="physx::"]
interface PxMaterialFlags {
    void PxMaterialFlags(unsigned short flags);
    boolean isSet(PxMaterialFlagEnum flag);
    void raise(PxMaterialFlagEnum flag);
    void clear(PxMaterialFlagEnum flag);
};

[Prefix="physx::"]
interface PxPhysics {
    // Basics
    void release();
    [Ref] PxFoundation getFoundation();
//    PxAggregate createAggregate(unsigned long size, boolean enableSelfCollision);
    [Const, Ref] PxTolerancesScale getTolerancesScale();
    // Scenes
    PxScene createScene([Const, Ref] PxSceneDesc sceneDesc);
    // Actors
    PxRigidStatic createRigidStatic([Const, Ref] PxTransform pose);
    PxRigidDynamic createRigidDynamic([Const, Ref] PxTransform pose);
    // Shapes
    PxShape createShape([Const, Ref] PxGeometry geometry, [Const, Ref] PxMaterial material, optional boolean isExclusive, [Ref] optional PxShapeFlags shapeFlags);
    long getNbShapes();
    // Constraints and Articulations
//    PxArticulation createArticulation();
//    PxArticulationReducedCoordinate createArticulationReducedCoordinate();
    // Materials
    PxMaterial createMaterial(float staticFriction, float dynamicFriction, float restitution);
    // Deletion Listeners
//    [Ref] PxPhysicsInsertionCallback getPhysicsInsertionCallback();
};

[Prefix="physx::", NoDelete]
interface PxRigidActor {
    // Global Pose Manipulation
    [Value] PxTransform getGlobalPose();
    void setGlobalPose([Const, Ref] PxTransform pose, optional boolean autowake);

    // Shapes
    boolean attachShape([Ref] PxShape shape);
    void detachShape([Ref] PxShape shape, optional boolean wakeOnLostTouch);
    long getNbShapes();
    //long getShapes(PxShape[] userBuffer, unsigned long bufferSize, unsigned long startIndex);
};
PxRigidActor implements PxActor;

[Prefix="physx::", NoDelete]
interface PxRigidBody {
//    // Mass Manipulation
//    void setCMassLocalPose([Const, Ref] PxTransform pose);
//    [Value] PxTransform getCMassLocalPose();
//    void setMass(float mass);
//    float getMass();
//    float getInvMass();
//    void setMassSpaceInertiaTensor([Const, Ref] PxVec3 m);
//    [Value] PxVec3 getMassSpaceInertiaTensor();
//    [Value] PxVec3 getMassSpaceInvInertiaTensor();
//
//    // Damping
//    void setLinearDamping(float linDamp);
//    float getLinearDamping();
//    void setAngularDamping(float angDamp);
//    float getAngularDamping();
//
//    // Velocity
//    [Value] PxVec3 getLinearVelocity();
//    void setLinearVelocity([Const, Ref] PxVec3 linVel, optional boolean autowake);
//    [Value] PxVec3 getAngularVelocity();
//    void setAngularVelocity([Const, Ref] PxVec3 angVel, optional boolean autowake);
//    float getMaxLinearVelocity();
//    void setMaxLinearVelocity(float maxLinVel);
//    float getMaxAngularVelocity();
//    void setMaxAngularVelocity(float maxAngVel);
//
//    // Forces
//    void addForce([Const, Ref] PxVec3 force, optional PxForceModeEnum mode, optional boolean autowake);
//    void addTorque([Const, Ref] PxVec3 torque, optional PxForceModeEnum mode, optional boolean autowake);
//    void clearForce(PxForceModeEnum mode);
//    void clearTorque(PxForceModeEnum mode);
//    void setForceAndTorque([Const, Ref] PxVec3 force, [Const, Ref] PxVec3 torque, optional PxForceModeEnum mode);
//
//    void setRigidBodyFlag(PxRigidBodyFlagEnum flag, boolean value);
//    void setRigidBodyFlags([Ref] PxRigidBodyFlags inFlags);
//    [Value] PxRigidBodyFlags getRigidBodyFlags();
//    void setMinCCDAdvanceCoefficient(float advanceCoefficient);
//    float getMinCCDAdvanceCoefficient();
//    void setMaxDepenetrationVelocity(float biasClamp);
//    float getMaxDepenetrationVelocity();
//    void setMaxContactImpulse(float maxImpulse);
//    float getMaxContactImpulse();
//    unsigned long getInternalIslandNodeIndex();
};
PxRigidBody implements PxRigidActor;

enum PxRigidBodyFlagEnum {
    "PxRigidBodyFlagEnum::eKINEMATIC",
    "PxRigidBodyFlagEnum::eUSE_KINEMATIC_TARGET_FOR_SCENE_QUERIES",
    "PxRigidBodyFlagEnum::eENABLE_CCD",
    "PxRigidBodyFlagEnum::eENABLE_CCD_FRICTION",
    "PxRigidBodyFlagEnum::eENABLE_POSE_INTEGRATION_PREVIEW",
    "PxRigidBodyFlagEnum::eENABLE_SPECULATIVE_CCD",
    "PxRigidBodyFlagEnum::eENABLE_CCD_MAX_CONTACT_IMPULSE",
    "PxRigidBodyFlagEnum::eRETAIN_ACCELERATIONS"
};

[Prefix="physx::"]
interface PxRigidBodyFlags {
    void PxRigidBodyFlags(octet flags);
    boolean isSet(PxRigidBodyFlagEnum flag);
    void raise(PxRigidBodyFlagEnum flag);
    void clear(PxRigidBodyFlagEnum flag);
};

[Prefix="physx::", NoDelete]
interface PxRigidDynamic {
    void setKinematicTarget([Const, Ref] PxTransform destination);
    boolean getKinematicTarget([Ref] PxTransform target);
    boolean isSleeping();
    void setSleepThreshold(float threshold);
    float getSleepThreshold();
    void setStabilizationThreshold(float threshold);
    float getStabilizationThreshold();
    [Value] PxRigidDynamicLockFlags getRigidDynamicLockFlags();
    void setRigidDynamicLockFlag(PxRigidDynamicLockFlagEnum flag, boolean value);
    void setRigidDynamicLockFlags([Ref] PxRigidDynamicLockFlags flags);
    void setWakeCounter(float wakeCounterValue);
    float getWakeCounter();
    void wakeUp();
    void putToSleep();
    void setSolverIterationCounts(unsigned long minPositionIters, optional unsigned long minVelocityIters);
    float getContactReportThreshold();
    void setContactReportThreshold(float threshold);
};
PxRigidDynamic implements PxRigidBody;

enum PxRigidDynamicLockFlagEnum {
    "PxRigidDynamicLockFlagEnum::eLOCK_LINEAR_X",
    "PxRigidDynamicLockFlagEnum::eLOCK_LINEAR_Y",
    "PxRigidDynamicLockFlagEnum::eLOCK_LINEAR_Z",
    "PxRigidDynamicLockFlagEnum::eLOCK_ANGULAR_X",
    "PxRigidDynamicLockFlagEnum::eLOCK_ANGULAR_Y",
    "PxRigidDynamicLockFlagEnum::eLOCK_ANGULAR_Z",
};

[Prefix="physx::"]
interface PxRigidDynamicLockFlags {
    void PxRigidDynamicLockFlags(octet flags);
    boolean isSet(PxRigidDynamicLockFlagEnum flag);
    void raise(PxRigidDynamicLockFlagEnum flag);
    void clear(PxRigidDynamicLockFlagEnum flag);
};

[Prefix="physx::", NoDelete]
interface PxRigidStatic { };
PxRigidStatic implements PxRigidActor;

[Prefix="physx::", NoDelete]
interface PxScene {
    void addActor([Ref] PxActor actor, [Const] optional PxBVHStructure bvhStructure);
    void removeActor([Ref] PxActor actor, optional boolean wakeOnLostTouch);
//    void addAggregate([Ref] PxAggregate aggregate);
//    void removeAggregate([Ref] PxAggregate aggregate, optional boolean wakeOnLostTouch);
//    void addCollection([Const, Ref] PxCollection collection);
//    float getWakeCounterResetValue();
//    void shiftOrigin([Const, Ref] PxVec3 shift);
//
//    // Add/Remove Contained Objects
//    void addArticulation([Ref] PxArticulationBase articulation);
//    void removeArticulation([Ref] PxArticulationBase articulation, optional boolean wakeOnLostTouch);

    // Contained Object Retrieval
    unsigned long getNbActors([Ref] PxActorTypeFlags types);
    // unsigned long getActors(...)
    // PxActorPtr getActiveActors();    -> SupportFunctions.PxScene_getActiveActors();
    unsigned long getNbArticulations();
    // unsigned long getArticulations(...);
    unsigned long getNbConstraints();
    // unsigned long getConstraints(...);
    unsigned long getNbAggregates();
    // unsigned long getAggregates(...);

    // Dominance
//    void setDominanceGroupPair(octet group1, octet group2, [Const, Ref] PxDominanceGroupPair dominance);
    //[Value] PxDominanceGroupPair getDominanceGroupPair(octet group1, octet group2);

    // Dispatcher
    PxCpuDispatcher getCpuDispatcher();
//    PxCudaContextManager getCudaContextManager();

    // Multiclient
    octet createClient();

//    // Callbacks
//    void setSimulationEventCallback(PxSimulationEventCallback callback);
//    PxSimulationEventCallback getSimulationEventCallback();
//    // set/get contact modify callback
//    // set/get ccd contact modify callback
//    // set/get broad phase callback
//
//    // collision filtering
//    void setFilterShaderData([Const] VoidPtr data, unsigned long dataSize);
//    [Const] VoidPtr getFilterShaderData();
//    unsigned long getFilterShaderDataSize();
//    [Value] PxSimulationFilterShader getFilterShader();
//    //PxSimulationFilterCallback getFilterCallback();
//    void resetFiltering([Ref] PxActor actor);
//    // void resetFiltering([Ref] PxActor actor, ...);
//    PxPairFilteringModeEnum getKinematicKinematicFilteringMode();
//    PxPairFilteringModeEnum getStaticKinematicFilteringMode();

    // Simulation
    void simulate(float elapsedTime, optional PxBaseTask completionTask, optional VoidPtr scratchMemBlock, optional unsigned long scratchMemBlockSize, optional boolean controlSimulation);
//    void advance(optional PxBaseTask completionTask);
//    void collide(float elapsedTime, optional PxBaseTask completionTask, optional VoidPtr scratchMemBlock, optional unsigned long scratchMemBlockSize, optional boolean controlSimulation);
//    boolean checkResults(optional boolean block);
//    boolean fetchCollision(optional boolean block);
    boolean fetchResults(optional boolean block);
//    // boolean fetchResultsStart();
//    void processCallbacks(PxBaseTask continuation);
//    // boolean fetchResultsFinish();
//    void flushSimulation(optional boolean sendPendingReports);
//    void setGravity([Const, Ref] PxVec3 vec);
//    [Value] PxVec3 getGravity();
//    void setBounceThresholdVelocity(float t);
//    float getBounceThresholdVelocity();
//    void setCCDMaxPasses(unsigned long ccdMaxPasses);
//    unsigned long getCCDMaxPasses();
//    float getFrictionOffsetThreshold();
//    void setFrictionType(PxFrictionTypeEnum frictionType);
//    PxFrictionTypeEnum getFrictionType();
//
//    // Visualization and Statistics
//    void getSimulationStatistics([Ref] PxSimulationStatistics stats);
//
//    // Scene Query
//    PxPruningStructureTypeEnum getStaticStructure();
//    PxPruningStructureTypeEnum getDynamicStructure();
//    void flushQueryUpdates();
//    PxBatchQuery createBatchQuery([Const, Ref] PxBatchQueryDesc desc);
//    void setDynamicTreeRebuildRateHint(unsigned long dynamicTreeRebuildRateHint);
//    unsigned long getDynamicTreeRebuildRateHint();
//    void forceDynamicTreeRebuild(boolean rebuildStaticStructure, boolean rebuildDynamicStructure);
//    void setSceneQueryUpdateMode(PxSceneQueryUpdateModeEnum updateMode);
//    PxSceneQueryUpdateModeEnum getSceneQueryUpdateMode();
//    void sceneQueriesUpdate(optional PxBaseTask completionTask, optional boolean controlSimulation);
//    boolean checkQueries(optional boolean block);
//    boolean fetchQueries(optional boolean block);
//    boolean raycast([Const, Ref] PxVec3 origin, [Const, Ref] PxVec3 unitDir, float distance, [Ref] PxRaycastCallback hitCall,
//                    [Ref] optional PxHitFlags hitFlags, [Const, Ref] optional PxQueryFilterData filterData);
//    boolean sweep([Const, Ref] PxGeometry geometry, [Const, Ref] PxTransform pose, [Const, Ref] PxVec3 unitDir, float distance,
//                    [Ref] PxSweepCallback hitCall, [Ref] optional PxHitFlags hitFlags, [Const, Ref] optional PxQueryFilterData filterData);
//    boolean overlap([Const, Ref] PxGeometry geometry, [Const, Ref] PxTransform pose, [Ref] PxOverlapCallback hitCall,
//                    [Const, Ref] optional PxQueryFilterData filterData);
//    unsigned long getSceneQueryStaticTimestamp();
//
//    // Broad-phase
//    PxBroadPhaseTypeEnum getBroadPhaseType();
//    boolean getBroadPhaseCaps([Ref] PxBroadPhaseCaps caps);
//    unsigned long getNbBroadPhaseRegions();
//    unsigned long getBroadPhaseRegions(PxBroadPhaseRegionInfo userBuffer, unsigned long bufferSize, optional unsigned long startIndex);
//    unsigned long addBroadPhaseRegion([Const, Ref] PxBroadPhaseRegion region, optional boolean populateRegion);
//    boolean removeBroadPhaseRegion(unsigned long handle);
//
//    // Threads and Memory
//    //PxTaskManager getTaskManager();
//    void lockRead(optional DOMString file, optional unsigned long line);
//    void unlockRead();
//    void lockWrite(optional DOMString file, optional unsigned long line);
//    void unlockWrite();
//    void setNbContactDataBlocks(unsigned long numBlocks);
//    unsigned long getNbContactDataBlocksUsed();
//    unsigned long getMaxNbContactDataBlocksUsed();
//    unsigned long getContactReportStreamBufferSize();
//    void setSolverBatchSize(unsigned long solverBatchSize);
//    unsigned long getSolverBatchSize();
//    void setSolverArticulationBatchSize(unsigned long solverBatchSize);
//    unsigned long getSolverArticulationBatchSize();

    // Basics
    void release();
    void setFlag([Value] PxSceneFlagEnum flag, boolean value);
    [Value] PxSceneFlags getFlags();
//    void setLimits([Const, Ref] PxSceneLimits limits);
//    [Value] PxSceneLimits getLimits();
    [Ref] PxPhysics getPhysics();
    unsigned long getTimestamp();

    attribute VoidPtr userData;
};

[Prefix="physx::"]
interface PxSceneDesc {
    void PxSceneDesc([Const, Ref] PxTolerancesScale scale);
    void setToDefault([Const, Ref] PxTolerancesScale scale);
    boolean isValid();

    [Value] attribute PxVec3 gravity;
//    attribute PxSimulationEventCallback simulationEventCallback;
//    // [Value] attribute PxContactModifyCallback contactModifyCallback;
//    // [Value] attribute PxCCDContactModifyCallback ccdContactModifyCallback;
//    [Const] attribute VoidPtr filterShaderData;
//    attribute unsigned long filterShaderDataSize;
    [Value] attribute PxSimulationFilterShader filterShader;
//    // [Value] attribute PxSimulationFilterCallback filterCallback;
//    attribute PxPairFilteringModeEnum kineKineFilteringMode;
//    attribute PxPairFilteringModeEnum staticKineFilteringMode;
//    attribute PxBroadPhaseTypeEnum broadPhaseType;
//    // [Value] PxBroadPhaseCallback broadPhaseCallback;
//    [Value] attribute PxSceneLimits limits;
//    attribute PxFrictionTypeEnum frictionType;
//    attribute PxSolverTypeEnum solverType;
//    attribute float bounceThresholdVelocity;
//    attribute float frictionOffsetThreshold;
//    attribute float ccdMaxSeparation;
//    attribute float solverOffsetSlop;
//    [Value] attribute PxSceneFlags flags;
    attribute PxCpuDispatcher cpuDispatcher;
//    attribute PxCudaContextManager cudaContextManager;
//    attribute PxPruningStructureTypeEnum staticStructure;
//    attribute PxPruningStructureTypeEnum dynamicStructure;
//    attribute unsigned long dynamicTreeRebuildRateHint;
//    attribute PxSceneQueryUpdateModeEnum sceneQueryUpdateMode;
//    attribute VoidPtr userData;
//    attribute unsigned long solverBatchSize;
//    attribute unsigned long solverArticulationBatchSize;
//    attribute unsigned long nbContactDataBlocks;
//    attribute float maxBiasCoefficient;
//    attribute unsigned long contactReportStreamBufferSize;
//    attribute unsigned long ccdMaxPasses;
//    attribute float ccdThreshold;
//    attribute float wakeCounterResetValue;
//    [Value] attribute PxBounds3 sanityBounds;
//    [Value] attribute PxgDynamicsMemoryConfig gpuDynamicsConfig;
//    attribute unsigned long gpuMaxNumPartitions;
//    attribute unsigned long gpuComputeVersion;
};

enum PxSceneFlagEnum {
    "PxSceneFlagEnum::eENABLE_ACTIVE_ACTORS",
    "PxSceneFlagEnum::eENABLE_CCD",
    "PxSceneFlagEnum::eDISABLE_CCD_RESWEEP",
    "PxSceneFlagEnum::eENABLE_PCM",
    "PxSceneFlagEnum::eDISABLE_CONTACT_REPORT_BUFFER_RESIZE",
    "PxSceneFlagEnum::eDISABLE_CONTACT_CACHE",
    "PxSceneFlagEnum::eREQUIRE_RW_LOCK",
    "PxSceneFlagEnum::eENABLE_STABILIZATION",
    "PxSceneFlagEnum::eENABLE_AVERAGE_POINT",
    "PxSceneFlagEnum::eEXCLUDE_KINEMATICS_FROM_ACTIVE_ACTORS",
    "PxSceneFlagEnum::eENABLE_GPU_DYNAMICS",
    "PxSceneFlagEnum::eENABLE_ENHANCED_DETERMINISM",
    "PxSceneFlagEnum::eENABLE_FRICTION_EVERY_ITERATION",
    "PxSceneFlagEnum::eSUPPRESS_READBACK",
    "PxSceneFlagEnum::eFORCE_READBACK",
    "PxSceneFlagEnum::eMUTABLE_FLAGS"
};

[Prefix="physx::"]
interface PxSceneFlags {
    void PxSceneFlags(unsigned long flags);
    boolean isSet(PxSceneFlagEnum flag);
    void raise(PxSceneFlagEnum flag);
    void clear(PxSceneFlagEnum flag);
};

[Prefix="physx::", NoDelete]
interface PxShape {
    unsigned long getReferenceCount();
    void acquireReference();
    PxGeometryTypeEnum getGeometryType();
    void setGeometry([Const, Ref] PxGeometry geometry);
//    [Value] PxGeometryHolder getGeometry();
    boolean getBoxGeometry([Ref] PxBoxGeometry geometry);
//    boolean getSphereGeometry([Ref] PxSphereGeometry geometry);
//    boolean getCapsuleGeometry([Ref] PxCapsuleGeometry geometry);
//    boolean getPlaneGeometry([Ref] PxPlaneGeometry geometry);
//    boolean getConvexMeshGeometry([Ref] PxConvexMeshGeometry geometry);
//    boolean getTriangleMeshGeometry([Ref] PxTriangleMeshGeometry geometry);
//    boolean getHeightFieldGeometry([Ref] PxHeightFieldGeometry geometry);
    PxRigidActor getActor();
//    void setMaterials(PxMaterialPtr materials, unsigned short materialCount);
    unsigned short getNbMaterials();
//    unsigned long getMaterials(PxMaterialPtr userBuffer, unsigned long bufferSize, unsigned long startIndex);
    PxMaterial getMaterialFromInternalFaceIndex(unsigned long faceIndex);
    void setContactOffset(float contactOffset);
    float getContactOffset();
    void setRestOffset(float restOffset);
    float getRestOffset();
    void setTorsionalPatchRadius(float radius);
    float getTorsionalPatchRadius();
    void setMinTorsionalPatchRadius(float radius);
    float getMinTorsionalPatchRadius();
    void setFlag(PxShapeFlagEnum flag, boolean value);
    void setFlags([Ref] PxShapeFlags inFlags);
    [Value] PxShapeFlags getFlags();
    boolean isExclusive();
    void setName([Const] DOMString name);
    [Const] DOMString getName();
    // Pose Manipulation
    void setLocalPose([Const, Ref] PxTransform pose);
    [Value] PxTransform getLocalPose();
    // Collision Filtering
    void setSimulationFilterData([Const, Ref] PxFilterData data);
    [Value] PxFilterData getSimulationFilterData();
    void setQueryFilterData([Const, Ref] PxFilterData data);
    [Value] PxFilterData getQueryFilterData();
    attribute VoidPtr userData;
};
PxShape implements PxBase;

enum PxShapeFlagEnum {
    "PxShapeFlagEnum::eSIMULATION_SHAPE",
    "PxShapeFlagEnum::eSCENE_QUERY_SHAPE",
    "PxShapeFlagEnum::eTRIGGER_SHAPE",
    "PxShapeFlagEnum::eVISUALIZATION"
};

[Prefix="physx::"]
interface PxShapeFlags {
    void PxShapeFlags(octet flags);
    boolean isSet(PxShapeFlagEnum flag);
    void raise(PxShapeFlagEnum flag);
    void clear(PxShapeFlagEnum flag);
};

[Prefix="physx::"]
interface PxSimulationFilterShader { };
